#pragma once

#include <string>
#include <iostream>
#include <deque>
#include <cassert>
#include <memory>
#include "converter/TypeConverter.h"
#include "MethodeInfo.h"
#include "FieldInfo.h"

#define STRINGIZE_NX(A) #A
#define STRINGIZE(A) STRINGIZE_NX(A)

namespace JNIHelper {
    class JavaObject;

    class JavaClass {
            friend class JavaObject;
            static std::shared_ptr<JavaClass> buildObjectClass();
        public:
            const std::string package;
            const std::string name;

            std::shared_ptr<JavaClass> getSuperClass() const {
                return superClass;
            }

            template<typename ReturnType, typename... Arguments>
            const std::unique_ptr<MethodInfoBase<ReturnType, Arguments...>>& registerMethod(std::string name, bool _static) {
                if (findMethod<ReturnType, Arguments...>(name))
                    throw Exceptions::ClassRegisterException("Method " + name + "(Signature: " + findMethod<ReturnType, Arguments...>(name)->signature() + ") already registered!");

                std::unique_ptr<MethodInfoBase<ReturnType, Arguments...>> method;
                if(_static){
                    method.reset(new StaticMethodInfo<ReturnType, Arguments...>(this, name));
                } else {
                    method.reset(new MethodInfoBase<ReturnType, Arguments...>(this, name, false)); //Instance method will be generated by class
                }

                methods.push_back(std::move(method));
                return this->findMethod<ReturnType, Arguments...>(name);
            };


            template<typename ReturnType, typename... Arguments>
            const std::unique_ptr<MethodInfoBase<ReturnType, Arguments...>>& findMethod(const std::string& name) {
                return find_method<MethodInfoBase<ReturnType, Arguments...>>(name);
            };

            template<typename ReturnType, typename... Arguments>
            const std::unique_ptr<StaticMethodInfo<ReturnType, Arguments...>>& findStaticMethod(const std::string& name) {
                return find_method<StaticMethodInfo<ReturnType, Arguments...>>(name);
            };

            template<typename ReturnType, typename... Arguments>
            const std::unique_ptr<MethodInfoBase<ReturnType, Arguments...>>& findOrGetMethod(std::string name, bool _static) {
                const auto& result = findMethod<ReturnType, Arguments...>(name);
                if(result) return result;
                return registerMethod<ReturnType, Arguments...>(name, _static);
            };

            const std::deque<std::unique_ptr<AbstractMethodInfo>>& getMethods(){
                return this->methods;
            }

            JavaField* findField(std::string name){
                for(auto field : fields)
                    if(field->name().compare(name) == 0) return field;
                return nullptr;
            }

            template <typename Type>
            JavaField* registerField(std::string name, bool _static){
                if(findField(name)) throw Exceptions::ClassRegisterException("Field " + name + " already registered!");

                Debug::debug(Debug::Type::RESOLVE, "Resolving field " + name + " (" + (_static ? "static" : "non-static") + ")" + " in class " + getJavaSignature());
                JavaField* field;

                std::string signature;
                if(Signature::TypeSignature<Type>::avariable()) signature = Signature::TypeSignature<Type>::signature();
                else signature = Signature::TypeSignature<typename CppToJniConverter<Type>::TargetType>::signature();
                if(_static) field = new StaticJavaField<Type>(this, name, signature);
                else field = new JavaField(this, name, signature, false);
                fields.push_back(field);
                return field;
            }

            template <typename Type>
            JavaField* getOrRegisterField(std::string name, bool _static){
                auto result = findField(name);
                if(result) return result;
                return registerField<Type>(name, _static);
            }

            void resolveClassInfo(){ //TODO make this private
                auto env = JNIHelper::getAttachedEnv();

                std::string package = this->package;
                size_t index = 0;
                while((index = package.find(".", index)) != std::string::npos){
                    package = package.replace(index, 1, "/");
                    index += 1;
                }

                Debug::debug(Debug::Type::RESOLVE, "Resolving class " + package + "/" + name);
                javaClass = env->FindClass((package + "/" + name).c_str());
                if(!javaClass) throw Exceptions::Exception("Cant resolve java class for " + package + "." + name + " (" + package + "/" + name + ")");

                jsig = "L" + package + "/" + name + ";";
            }

            jclass getJavaClass(){
                return javaClass;
            }

            std::string getName(){
                return package + "." + name;
            };

            std::string getJavaSignature(){
                return jsig;
            }
        private:
            template<typename Type>
            const std::unique_ptr<Type>& find_method(const std::string& name) {
                for (const auto& method : methods)
                    if (method->name().compare(name) == 0)
                        if (dynamic_cast<Type*>(method.get()))
                            return *(std::unique_ptr<Type>*) & method;
                return Helper::unique_null_t<Type>();
            };

            std::shared_ptr<JavaClass> superClass;
            std::deque<std::unique_ptr<AbstractMethodInfo>> methods;
            std::deque<JavaField *> fields;
            jclass javaClass = nullptr;
            std::string jsig;

            JavaClass(std::string package, std::string name, const std::shared_ptr<JavaClass>& superClass);
    };

    class JavaObject {
        public:
            static std::shared_ptr<JNIHelper::JavaClass> getClass() { return getDescription("java_lang", "Object", nullptr); }; //As super class nullptr becorde java lang object should be inizalisized
        protected:
            static std::shared_ptr<JavaClass> getDescription(const std::string& package, const std::string& name, const std::shared_ptr<JavaClass>& superClass);
            /**
             * @param package
             * @param name
             * @return May be null
             */
            static std::shared_ptr<JavaClass> find_description(const std::string& package, const std::string& name);

        private:
            static std::deque<std::shared_ptr<JavaClass>> classes;

        public:
            JavaObject(std::shared_ptr<void*> javaInstance);
            JavaObject(const JavaObject& ref);
            JavaObject();

            virtual ~JavaObject();

            template<typename ReturnType, typename... Arguments>
            const std::unique_ptr<InstanceMethodInfo<ReturnType, Arguments...>>& getMethod(const std::string& name) {
                for (const auto& method : methods)
                    if (method->name().compare(name) == 0)
                        if (dynamic_cast<InstanceMethodInfo<ReturnType, Arguments...> *>(method.get()))
                            return *(std::unique_ptr<InstanceMethodInfo<ReturnType, Arguments...>>*) &method;
                const auto& methodInfo = getObjectClass()->findOrGetMethod<ReturnType, Arguments...>(name, false);
                assert(methodInfo != nullptr); //TODO throw exception
                std::unique_ptr<InstanceMethodInfo<ReturnType, Arguments...>> method;
                method.reset(new InstanceMethodInfo<ReturnType, Arguments...>(methodInfo, (jobject) javaInstance.get()));
                methods.push_back(std::move(method));
                return this->getMethod<ReturnType, Arguments...>(name);
            };

            jobject getJavaObject() const {
                return (jobject) javaInstance.get();
            }

            /**
             * @return The class from a object (just c++ typed not bound to the java object!)
             */
            virtual std::shared_ptr<JNIHelper::JavaClass> getObjectClass() { return JavaObject::getClass(); }
        protected:
            void constructNewObject();
        private:
            std::deque<std::unique_ptr<AbstractMethodInfo>> methods;
            std::shared_ptr<void*> javaInstance = nullptr;
    };
}

#define DEFINE_CLASS_CONVERTER(name)  \
namespace JNIHelper { \
    DEFINE_CPP_JNI_CONVERTER(name, jobject, return JNIHelper::DefaultConverterImpl::convertJObject((JavaObject*) &src)); \
    DEFINE_CPP_JNI_CONVERTER(name*, jobject, return JNIHelper::DefaultConverterImpl::convertJObject((JavaObject*) src)); \
    DEFINE_CPP_JNI_CONVERTER(name&, jobject, return JNIHelper::DefaultConverterImpl::convertJObject((JavaObject*) &src)); \
    DEFINE_CPP_JNI_CONVERTER(const name&, jobject, return JNIHelper::DefaultConverterImpl::convertJObject((JavaObject*) &src)); \
    DEFINE_JNI_CPP_CONVERTER(jobject, name*, return new name(JNIHelper::DefaultConverterImpl::createJavaObjectPtr(src))) \
    DEFINE_JNI_CPP_CONVERTER(jobject, name, return name(JNIHelper::DefaultConverterImpl::createJavaObjectPtr(src))) \
    namespace Signature { \
        DEFINE_TYPE_SIGNATURE(name, name::getClass()->getJavaSignature()); \
        DEFINE_TYPE_SIGNATURE(name*, name::getClass()->getJavaSignature()); \
        DEFINE_TYPE_SIGNATURE(name&, name::getClass()->getJavaSignature()); \
        DEFINE_TYPE_SIGNATURE(const name&, name::getClass()->getJavaSignature()); \
    }\
}
DEFINE_CLASS_CONVERTER(JNIHelper::JavaObject)

#define PREDEFINE_JAVA_CLASS(package, name) \
namespace package { \
    class name;     \
}

#define   DEFINE_JAVA_CLASS(package, name, superClass, content)           \
namespace package { \
    class name : public superClass {       \
        public:     \
            static std::shared_ptr<JNIHelper::JavaClass> getClass(){ return JNIHelper::JavaObject::getDescription(STRINGIZE(package), STRINGIZE(name), superClass::getClass()); }       \
        public: \
            name() : superClass() { constructNewObject(); } \
            name(std::shared_ptr<void*> javaInstance) : superClass(javaInstance) {} \
            virtual std::shared_ptr<JNIHelper::JavaClass> getObjectClass() override { return name::getClass(); } \
            content \
    }; \
}  \
DEFINE_CLASS_CONVERTER(package::name)


#define DEFINE_STATIC_METHODE(methodeName, return_type, ...)                                                                                        \
public:                                                                                                                                             \
    static return_type methodeName(__VA_ARGS__){                                                                                                    \
        __asm__ ("\tmovq %0, %%rax;" ::"r"((long) JNIHelper::CPPJValueArgsConverter<return_type, ##__VA_ARGS__>::expendArgumentsS));                \
        __asm__ ("\tcall %rax");                                                                                                                    \
        std::vector<jvalue>* result = nullptr;                                                                                                      \
        __asm__("\rmovq %%rax, %0" : "=r"(result));                                                                                                 \
        assert(result != nullptr);                                                                                                                  \
        std::vector<jvalue> arguments = std::vector<jvalue>(*result);                                                                               \
        delete result;                                                                                                                              \
        const auto& methode = getClass()->findOrGetMethod<return_type, ##__VA_ARGS__>(STRINGIZE(methodeName), true);                                      \
        assert(methode != nullptr);                                                                                                                 \
        return methode->invokeStatic(arguments);                                                                                                    \
    }


#define DEFINE_METHODE(methodeName, return_type, ...)                                                                                               \
public:                                                                                                                                             \
    virtual return_type methodeName(__VA_ARGS__){                                                                                                   \
        __asm__ ("\tmovq %0, %%rax;" ::"r"((long) JNIHelper::CPPJValueArgsConverter<return_type, ##__VA_ARGS__>::expendArgumentsI));                \
        __asm__ ("\tcall %rax");                                                                                                                    \
        std::vector<jvalue>* result = nullptr;                                                                                                      \
        __asm__("\rmovq %%rax, %0" : "=r"(result));                                                                                                 \
        assert(result != nullptr);                                                                                                                  \
        std::vector<jvalue> arguments = std::vector<jvalue>(*result);                                                                               \
        delete result;                                                                                                                              \
        const auto& methode = getMethod<return_type, ##__VA_ARGS__>(STRINGIZE(methodeName));                                                               \
        assert(methode != nullptr);                                                                                                                 \
        return methode->invokeObject(arguments);                                                                                                    \
    }

#define DEFINE_CONSTRUCTOR(cppMethodeName, ...)                                                                                                     \
public:                                                                                                                                             \
    virtual void cppMethodeName(__VA_ARGS__){                                                                                                       \
        __asm__ ("\tmovq %0, %%rax;" ::"r"((long) JNIHelper::CPPJValueArgsConverter<void, ##__VA_ARGS__>::expendArgumentsI));                       \
        __asm__ ("\tcall %rax");                                                                                                                    \
        std::vector<jvalue>* result = nullptr;                                                                                                      \
        __asm__("\rmovq %%rax, %0" : "=r"(result));                                                                                                 \
        assert(result != nullptr);                                                                                                                  \
        std::vector<jvalue> arguments = std::vector<jvalue>(*result);                                                                               \
        delete result;                                                                                                                              \
        const auto& methode = getMethod<void, ##__VA_ARGS__>(std::string("<init>"));                                                                      \
        assert(methode != nullptr);                                                                                                                 \
        methode->invokeObject(arguments);                                                                                                           \
    }

#define DEFINE_DEFAULT_CONSTRUCTOR(cppMethodName) DEFINE_CONSTRUCTOR(cppMethodName)

#define DEFINE_STATIC_FIELD(fieldName, fieldType, cppMethodName) \
public:\
    static JNIHelper::StaticJavaField<fieldType> cppMethodName(){\
            return *(JNIHelper::StaticJavaField<fieldType>*) getClass()->getOrRegisterField<fieldType>(STRINGIZE(fieldName), true); \
            \
    }

#define DEFINE_FIELD(fieldName, fieldType) \
public:\
    const JNIHelper::InstanceJavaField<fieldType> fieldName = JNIHelper::InstanceJavaField<fieldType>(getClass()->getOrRegisterField<fieldType>(STRINGIZE(fieldName), false), this);
